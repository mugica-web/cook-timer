<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cooking Timer</title>

    <!-- Link to our CSS stylesheet for visual styling -->
    <link rel="stylesheet" href="/static/style.css">

    <!-- Firebase SDK (loaded from Google's CDN ‚Äî no install needed).
         We use the "compat" version which works with simple <script> tags.
         Three parts: the core app, authentication, and Firestore database. -->
    <script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-firestore-compat.js"></script>
</head>
<body>

    <h1>üç≥ Cooking Timer</h1>

    <!-- ========== USER BAR ========== -->
    <!-- Shown when logged in. Displays the user's email and a sign-out button. -->
    <div id="user-bar" class="user-bar" style="display: none;">
        <span id="user-email"></span>
        <button onclick="logOut()" class="btn btn-logout">Sign Out</button>
    </div>

    <!-- ========== AUTH SECTION ========== -->
    <!-- Shown when NOT logged in. The user must sign in before using the app. -->
    <div id="auth-section">
        <h2>Sign in to sync your dishes</h2>
        <div class="auth-form">
            <input type="email" id="auth-email" placeholder="Email address" class="auth-input">
            <input type="password" id="auth-password" placeholder="Password" class="auth-input">
            <div class="auth-buttons">
                <button onclick="emailLogIn()" class="btn btn-login">Log In</button>
                <button onclick="emailSignUp()" class="btn btn-signup">Sign Up</button>
            </div>
            <div class="auth-divider"><span>or</span></div>
            <button onclick="googleSignIn()" class="btn btn-google">Sign in with Google</button>
            <p id="auth-error" class="auth-error"></p>
        </div>
    </div>

    <!-- ========== SETUP SECTION ========== -->
    <!-- This is where the user adds dishes and steps BEFORE starting.
         Hidden by default ‚Äî shown after the user signs in. -->
    <div id="setup-section" style="display: none;">
        <h2>Plan Your Meal</h2>

        <!-- Timing mode toggle: should everything START or FINISH at the same time? -->
        <div class="mode-toggle">
            <span class="mode-label">Timing mode:</span>
            <div class="toggle-buttons">
                <!-- When "Start Together" is selected, all dishes begin cooking at once.
                     Each step fires at its offset from now.
                     Example: Chicken "flip" at 15 min fires 15 min from now. -->
                <button id="mode-start" class="btn btn-mode active" onclick="setMode('start')">
                    Start Together
                </button>
                <!-- When "Finish Together" is selected, the app works BACKWARDS so all
                     dishes finish at the same time. Shorter dishes start later.
                     Example: If chicken takes 45 min and rice takes 20 min,
                     rice won't start until 25 min in. -->
                <button id="mode-finish" class="btn btn-mode" onclick="setMode('finish')">
                    Finish Together
                </button>
                <!-- "Done By" mode lets the user pick a clock time (e.g. 6:00 PM)
                     and the app works backward so all dishes are done by then. -->
                <button id="mode-done-by" class="btn btn-mode" onclick="setMode('done-by')">
                    Done By
                </button>
            </div>
            <p class="mode-description" id="mode-description">
                All dishes start cooking at the same time.
            </p>
            <!-- Time picker ‚Äî only visible in "done-by" mode -->
            <div id="done-by-picker" class="done-by-picker" style="display: none;">
                <label for="done-by-time">Everything done by:</label>
                <input type="time" id="done-by-time" class="done-by-time-input">
            </div>
        </div>

        <!-- Container where dish cards will be added dynamically -->
        <div id="dishes-container"></div>

        <!-- Buttons to add a dish and to start all timers -->
        <div class="button-row">
            <button onclick="addDish()" class="btn btn-add">+ Add Dish</button>
            <button onclick="startCooking()" class="btn btn-start">Start Cooking!</button>
        </div>

        <!-- ========== SAVED DISHES SECTION ========== -->
        <!-- Shows dishes previously saved to localStorage. Users can load
             them into the active setup or delete them. -->
        <div id="saved-section">
            <h3>Saved Dishes</h3>
            <div id="saved-dishes-container">
                <p class="saved-empty">No saved dishes yet. Use the "Save" button on a dish to save it.</p>
            </div>
        </div>
    </div>

    <!-- ========== TIMER SECTION ========== -->
    <!-- Hidden at first, shown when "Start Cooking" is clicked -->
    <div id="timer-section" style="display: none;">
        <h2>Cooking In Progress...</h2>
        <!-- Shows the target finish time when in "done-by" mode -->
        <p id="done-by-info" class="done-by-info" style="display: none;"></p>

        <!-- Live countdowns will be displayed here -->
        <div id="timers-container"></div>

        <!-- Button to stop and go back to setup -->
        <button onclick="stopCooking()" class="btn btn-stop">Stop & Reset</button>
    </div>

    <script>
    // ================================================================
    // JAVASCRIPT ‚Äî All the interactive logic for our cooking timer
    // ================================================================


    // ---- FIREBASE INITIALIZATION ----
    //
    // firebase.initializeApp() connects our app to our Firebase project.
    // The config object contains public keys that identify our project ‚Äî
    // they're safe to include in client-side code (security comes from
    // Firestore rules, not from hiding these keys).
    firebase.initializeApp({
        apiKey: "***REMOVED***",
        authDomain: "cook-timer-69256.firebaseapp.com",
        projectId: "cook-timer-69256",
        storageBucket: "cook-timer-69256.firebasestorage.app",
        messagingSenderId: "207322185688",
        appId: "1:207322185688:web:92edf8b87f61abee85bcad"
    });

    // Shorthand references so we don't have to type firebase.auth() everywhere
    const auth = firebase.auth();
    const db = firebase.firestore();


    // ---- AUTHENTICATION FUNCTIONS ----

    // emailLogIn() ‚Äî Signs in with an existing email + password account.
    function emailLogIn() {
        const email = document.getElementById("auth-email").value;
        const password = document.getElementById("auth-password").value;
        const errorEl = document.getElementById("auth-error");
        errorEl.textContent = "";

        auth.signInWithEmailAndPassword(email, password)
            .catch(function(error) {
                errorEl.textContent = error.message;
            });
    }

    // emailSignUp() ‚Äî Creates a NEW account with email + password.
    // After sign-up, the user is automatically logged in.
    function emailSignUp() {
        const email = document.getElementById("auth-email").value;
        const password = document.getElementById("auth-password").value;
        const errorEl = document.getElementById("auth-error");
        errorEl.textContent = "";

        auth.createUserWithEmailAndPassword(email, password)
            .catch(function(error) {
                errorEl.textContent = error.message;
            });
    }

    // googleSignIn() ‚Äî Opens a Google sign-in popup.
    function googleSignIn() {
        const provider = new firebase.auth.GoogleAuthProvider();
        auth.signInWithPopup(provider)
            .catch(function(error) {
                document.getElementById("auth-error").textContent = error.message;
            });
    }

    // logOut() ‚Äî Signs the user out and returns to the login screen.
    function logOut() {
        auth.signOut();
    }


    // ---- AUTH STATE LISTENER ----
    //
    // onAuthStateChanged fires whenever the user logs in or out.
    // It controls which sections are visible:
    //   - Logged out ‚Üí show auth section, hide everything else
    //   - Logged in  ‚Üí hide auth section, show setup + user bar
    auth.onAuthStateChanged(function(user) {
        const authSection = document.getElementById("auth-section");
        const setupSection = document.getElementById("setup-section");
        const userBar = document.getElementById("user-bar");
        const userEmail = document.getElementById("user-email");

        if (user) {
            // User is logged in ‚Äî show the app
            authSection.style.display = "none";
            setupSection.style.display = "block";
            userBar.style.display = "flex";
            userEmail.textContent = user.email || user.displayName || "User";

            // Start listening to this user's saved dishes in Firestore
            setupDishesListener(user);
        } else {
            // User is logged out ‚Äî show the login form
            authSection.style.display = "block";
            setupSection.style.display = "none";
            document.getElementById("timer-section").style.display = "none";
            userBar.style.display = "none";

            // Clean up the Firestore listener
            setupDishesListener(null);
        }
    });


    // ---- APP VARIABLES ----

    // This counter gives each dish a unique ID so we can tell them apart.
    let dishCounter = 0;

    // This will hold our setInterval ID so we can stop the countdown loop.
    let timerInterval = null;

    // Data model for active cooking timers:
    //
    // activeDishes = [
    //   {
    //     name: "Chicken",
    //     currentStep: 0,        // index of the step currently counting down
    //     done: false,           // true when all steps have fired
    //     steps: [
    //       { action: "Put in oven", fireTime: Date, fired: false, isWait: false },
    //       { action: "Flip",        fireTime: Date, fired: false, isWait: false },
    //     ]
    //   }
    // ]
    let activeDishes = [];

    // Timing mode: "start" = all dishes start together,
    //              "finish" = all dishes finish together,
    //              "done-by" = all dishes done by a specific clock time.
    let timingMode = "start";

    // Cache of saved dishes from Firestore.
    // Each item: { id: "firestore-doc-id", name: "Pasta", steps: [...] }
    // This is kept in sync automatically by the onSnapshot listener.
    let cachedSavedDishes = [];

    // Holds the Firestore listener cleanup function so we can
    // unsubscribe when the user logs out or switches accounts.
    let unsubscribeDishes = null;


    // setMode(mode) ‚Äî Switches between "start together" and "finish together".
    // Updates the button styling and description text.
    function setMode(mode) {
        timingMode = mode;

        // Update button styles ‚Äî "active" class highlights the selected one
        document.getElementById("mode-start").className =
            "btn btn-mode" + (mode === "start" ? " active" : "");
        document.getElementById("mode-finish").className =
            "btn btn-mode" + (mode === "finish" ? " active" : "");
        document.getElementById("mode-done-by").className =
            "btn btn-mode" + (mode === "done-by" ? " active" : "");

        // Update the description text below the toggle
        const desc = document.getElementById("mode-description");
        if (mode === "start") {
            desc.textContent = "All dishes start cooking at the same time.";
        } else if (mode === "finish") {
            desc.textContent = "All dishes finish at the same time. Shorter dishes start later.";
        } else {
            desc.textContent = "Pick a time ‚Äî the app tells you when to start each dish.";
        }

        // Show/hide the time picker (only visible in "done-by" mode)
        const picker = document.getElementById("done-by-picker");
        picker.style.display = (mode === "done-by") ? "block" : "none";

        // Set a default time when first switching to done-by mode
        // (round up to the next 15-minute mark, plus 1 hour)
        const timeInput = document.getElementById("done-by-time");
        if (mode === "done-by" && !timeInput.value) {
            const now = new Date();
            now.setHours(now.getHours() + 1);
            now.setMinutes(Math.ceil(now.getMinutes() / 15) * 15, 0, 0);
            const hh = String(now.getHours()).padStart(2, "0");
            const mm = String(now.getMinutes()).padStart(2, "0");
            timeInput.value = hh + ":" + mm;
        }
    }


    // ---- SETUP FUNCTIONS ----

    // addDish() ‚Äî Creates a new dish card in the setup section.
    // Called when the user clicks "+ Add Dish".
    function addDish() {
        dishCounter++;
        const dishId = dishCounter;

        // Create a new <div> element for this dish
        const dishDiv = document.createElement("div");
        dishDiv.className = "dish-card";
        dishDiv.id = "dish-" + dishId;

        // Set the HTML inside the dish card.
        // It includes:
        //   - A text input for the dish name
        //   - A container for steps
        //   - A button to add steps
        //   - A button to remove the dish
        dishDiv.innerHTML =
            '<div class="dish-header">' +
                '<input type="text" placeholder="Dish name (e.g. Chicken)" class="dish-name">' +
                '<div class="dish-header-buttons">' +
                    '<button onclick="saveDish(' + dishId + ')" class="btn btn-save">Save</button>' +
                    '<button onclick="removeDish(' + dishId + ')" class="btn btn-remove">Remove</button>' +
                '</div>' +
            '</div>' +
            '<div class="steps-container" id="steps-' + dishId + '"></div>' +
            '<button onclick="addStep(' + dishId + ')" class="btn btn-add-step">+ Add Step</button>';

        // Append the dish card to the dishes container
        document.getElementById("dishes-container").appendChild(dishDiv);

        // Automatically add one step to get the user started
        addStep(dishId);
    }


    // addStep(dishId) ‚Äî Adds a new step row to a dish.
    // Each step has: an action description and a time in minutes.
    function addStep(dishId) {
        const stepsContainer = document.getElementById("steps-" + dishId);

        const stepDiv = document.createElement("div");
        stepDiv.className = "step-row";

        stepDiv.innerHTML =
            '<input type="text" placeholder="Action (e.g. Flip chicken)" class="step-action">' +
            '<input type="number" placeholder="Min" min="0" step="0.1" class="step-minutes" title="How long this step takes (decimals OK, e.g. 2.5 = 2m 30s)">' +
            '<span class="step-label">min</span>' +
            '<button onclick="this.parentElement.remove()" class="btn btn-remove-step">‚úï</button>';

        stepsContainer.appendChild(stepDiv);
    }


    // removeDish(dishId) ‚Äî Removes an entire dish card from the page.
    function removeDish(dishId) {
        const dish = document.getElementById("dish-" + dishId);
        if (dish) {
            dish.remove();
        }
    }


    // ---- COOKING / TIMER FUNCTIONS ----

    // startCooking() ‚Äî Reads all dishes and steps, builds the activeDishes
    // array, and switches to the timer view.
    function startCooking() {
        activeDishes = [];
        const now = new Date();

        // Find all dish cards on the page
        const dishCards = document.querySelectorAll(".dish-card");

        if (dishCards.length === 0) {
            alert("Add at least one dish first!");
            return;
        }

        // First pass: collect all dishes and their steps.
        // We need ALL the data before calculating times, because "finish together"
        // mode needs to know the longest dish duration first.
        const rawDishes = [];

        dishCards.forEach(function(card) {
            const dishName = card.querySelector(".dish-name").value || "Unnamed Dish";
            const stepRows = card.querySelectorAll(".step-row");
            const steps = [];

            stepRows.forEach(function(row) {
                const action = row.querySelector(".step-action").value || "Do something";
                // parseFloat instead of parseInt ‚Äî this handles decimals like 2.5
                const minutes = parseFloat(row.querySelector(".step-minutes").value) || 0;
                steps.push({ action: action, minutes: minutes });
            });

            if (steps.length > 0) {
                // Each step's "minutes" is a DURATION (how long that step takes).
                // Total cooking time = sum of all step durations.
                //   Example: "Boil water" 5 min + "Cook pasta" 10 min + "Drain" 1 min = 16 min total
                const totalMinutes = steps.reduce(function(sum, s) { return sum + s.minutes; }, 0);
                rawDishes.push({ name: dishName, steps: steps, totalMinutes: totalMinutes });
            }
        });

        if (rawDishes.length === 0) {
            alert("Add at least one step to a dish!");
            return;
        }

        // For "finish together" mode, find the longest total cooking time.
        // All dishes will be aligned so they finish at the same moment.
        const overallMax = Math.max(...rawDishes.map(function(d) { return d.totalMinutes; }));

        // For "done-by" mode, calculate how many minutes until the target time.
        // This replaces overallMax as the anchor ‚Äî instead of aligning to the
        // longest dish, we align everything to a specific clock time.
        let totalAvailableMinutes = overallMax; // default for non-done-by modes

        if (timingMode === "done-by") {
            const timeInput = document.getElementById("done-by-time");
            if (!timeInput.value) {
                alert("Pick a target time first!");
                return;
            }

            // Parse the time input (e.g. "18:00") into a Date for today
            const parts = timeInput.value.split(":");
            const targetDate = new Date();
            targetDate.setHours(parseInt(parts[0]), parseInt(parts[1]), 0, 0);

            // If the target time has already passed today, assume tomorrow
            if (targetDate <= now) {
                targetDate.setDate(targetDate.getDate() + 1);
            }

            totalAvailableMinutes = (targetDate - now) / 60000;

            // Check that there's enough time for the longest dish
            const longestDish = rawDishes.reduce(function(longest, d) {
                return d.totalMinutes > longest.totalMinutes ? d : longest;
            }, rawDishes[0]);

            if (longestDish.totalMinutes > totalAvailableMinutes) {
                const needed = Math.ceil(longestDish.totalMinutes);
                const available = Math.floor(totalAvailableMinutes);
                alert(
                    '"' + longestDish.name + '" needs ' + needed + ' min, ' +
                    "but there are only " + available + " min until " +
                    formatTimeForDisplay(targetDate) + ".\n\n" +
                    "Pick a later time or shorten your dishes."
                );
                return;
            }
        }

        // Second pass: build the activeDishes array with fire times.
        rawDishes.forEach(function(dish) {
            // In "start together" mode, the delay is 0 ‚Äî everything starts now.
            // In "finish together" mode, shorter dishes are delayed so they
            // finish when the longest dish finishes.
            // In "done-by" mode, dishes are delayed so they all finish by the
            // target clock time (totalAvailableMinutes replaces overallMax).
            //   Example: longest dish = 45 min total, this dish = 16 min total
            //            delay = 45 - 16 = 29 min (this dish starts 29 min late)
            let delayMinutes;
            if (timingMode === "start") {
                delayMinutes = 0;
            } else if (timingMode === "finish") {
                delayMinutes = overallMax - dish.totalMinutes;
            } else {
                // done-by: use the available time until target as the anchor
                delayMinutes = totalAvailableMinutes - dish.totalMinutes;
            }

            const timerSteps = [];

            // If in "finish together" mode and this dish has a delay,
            // insert a "waiting" step at the front. This counts down until
            // the dish actually needs to start cooking.
            if (delayMinutes > 0) {
                const waitFireTime = new Date(now.getTime() + delayMinutes * 60 * 1000);
                timerSteps.push({
                    action: "Start " + dish.name,
                    fireTime: waitFireTime,
                    fired: false,
                    isWait: true    // flag so we can style it differently
                });
            }

            // Add the actual cooking steps with cumulative fire times.
            // Each step fires after all previous steps have completed.
            //   Example: step durations are 5, 10, 1 minutes
            //            fire times: 5 min, 15 min (5+10), 16 min (5+10+1)
            //   With a delay of 29 min:
            //            fire times: 34 min, 44 min, 45 min
            let cumulativeMinutes = delayMinutes;

            dish.steps.forEach(function(step) {
                // Add this step's duration to the running total
                cumulativeMinutes += step.minutes;

                const fireTime = new Date(now.getTime() + cumulativeMinutes * 60 * 1000);

                timerSteps.push({
                    action: step.action,
                    fireTime: fireTime,
                    fired: false,
                    isWait: false
                });
            });

            activeDishes.push({
                name: dish.name,
                currentStep: 0,     // start at the first step
                done: false,
                steps: timerSteps
            });
        });

        // Ask the browser for notification permission.
        if ("Notification" in window && Notification.permission === "default") {
            Notification.requestPermission();
        }

        // Switch from setup view to timer view
        document.getElementById("setup-section").style.display = "none";
        document.getElementById("timer-section").style.display = "block";

        // In "done-by" mode, show the target finish time in the timer view
        const doneByInfo = document.getElementById("done-by-info");
        if (timingMode === "done-by") {
            const parts = document.getElementById("done-by-time").value.split(":");
            const targetDate = new Date();
            targetDate.setHours(parseInt(parts[0]), parseInt(parts[1]), 0, 0);
            if (targetDate <= now) {
                targetDate.setDate(targetDate.getDate() + 1);
            }
            doneByInfo.textContent = "Everything done by " + formatTimeForDisplay(targetDate);
            doneByInfo.style.display = "block";
        } else {
            doneByInfo.style.display = "none";
        }

        // Build the timer display ‚Äî one card per dish
        renderDishes();

        // Start the countdown loop ‚Äî runs every second (1000 milliseconds)
        timerInterval = setInterval(updateTimers, 1000);
    }


    // renderDishes() ‚Äî Creates one timer card per dish, showing only
    // the current step for each dish.
    function renderDishes() {
        const container = document.getElementById("timers-container");
        container.innerHTML = "";

        activeDishes.forEach(function(dish, index) {
            const div = document.createElement("div");
            div.id = "dish-timer-" + index;
            container.appendChild(div);

            // Render the current step into this dish's card
            renderDishCard(index);
        });
    }


    // renderDishCard(dishIndex) ‚Äî Updates a single dish's timer card
    // to show its current step. Called on initial render and when
    // advancing to the next step.
    function renderDishCard(dishIndex) {
        const dish = activeDishes[dishIndex];
        const container = document.getElementById("dish-timer-" + dishIndex);
        if (!container) return;

        // If all steps are done, show a completed card
        if (dish.done) {
            container.innerHTML =
                '<div class="timer-card done">' +
                    '<div class="timer-dish">' + dish.name + '</div>' +
                    '<div class="timer-action">All done!</div>' +
                    '<div class="timer-countdown">Done</div>' +
                    '<div class="timer-progress">All steps completed</div>' +
                '</div>';
            return;
        }

        const step = dish.steps[dish.currentStep];

        // Count only real cooking steps (exclude the auto-inserted wait step)
        // so progress shows "Step 1 of 3" not "Step 2 of 4"
        const hasWait = dish.steps[0].isWait;
        const cookingSteps = hasWait ? dish.steps.length - 1 : dish.steps.length;
        const cookingStepNumber = hasWait
            ? dish.currentStep       // wait is index 0, so first cooking step is index 1 ‚Üí display 1
            : dish.currentStep + 1;

        // Determine the CSS class based on whether this is a "wait" step
        const cardClass = step.isWait ? "timer-card waiting" : "timer-card upcoming";

        // Show which step we're on (e.g., "Step 2 of 3")
        const progressText = step.isWait
            ? "Waiting to start..."
            : "Step " + cookingStepNumber + " of " + cookingSteps;

        container.innerHTML =
            '<div class="' + cardClass + '">' +
                '<div class="timer-dish">' + dish.name + '</div>' +
                '<div class="timer-action">' + step.action + '</div>' +
                '<div class="timer-countdown" id="countdown-' + dishIndex + '">--:--</div>' +
                '<div class="timer-progress">' + progressText + '</div>' +
            '</div>';
    }


    // updateTimers() ‚Äî Called every second by setInterval.
    // For each dish, counts down the current step. When it fires,
    // advances to the next step in that dish's queue.
    function updateTimers() {
        const now = new Date();
        let allDone = true;

        activeDishes.forEach(function(dish, dishIndex) {
            // Skip dishes that are fully completed
            if (dish.done) return;

            allDone = false;

            const step = dish.steps[dish.currentStep];
            const countdownEl = document.getElementById("countdown-" + dishIndex);
            const container = document.getElementById("dish-timer-" + dishIndex);

            if (!countdownEl || !container) return;

            // Get the card element (the first child of the container div)
            const cardEl = container.querySelector(".timer-card");

            // Calculate remaining time in seconds
            const remaining = Math.round((step.fireTime - now) / 1000);

            if (remaining <= 0 && !step.fired) {
                // STEP FIRED! ‚Äî Time to alert the user
                step.fired = true;
                countdownEl.textContent = "NOW!";

                if (cardEl) cardEl.className = "timer-card fired";

                // Play beep and send notification (skip beep for wait steps)
                if (!step.isWait) {
                    playBeep();
                }
                sendNotification(dish.name, step.action);

                // After 3 seconds, advance to the next step (or mark done)
                setTimeout(function() {
                    advanceDish(dishIndex);
                }, 3000);

            } else if (!step.fired) {
                // Timer is still counting down
                const mins = Math.floor(remaining / 60);
                const secs = remaining % 60;
                countdownEl.textContent =
                    String(mins).padStart(2, "0") + ":" +
                    String(secs).padStart(2, "0");

                // Color-code based on urgency
                if (cardEl) {
                    if (step.isWait) {
                        cardEl.className = "timer-card waiting";
                    } else if (remaining <= 30) {
                        cardEl.className = "timer-card imminent";
                    } else {
                        cardEl.className = "timer-card upcoming";
                    }
                }
            }
        });

        // If every dish is done, stop the interval loop
        if (allDone) {
            clearInterval(timerInterval);
        }
    }


    // advanceDish(dishIndex) ‚Äî Moves a dish to its next step, or marks
    // it as done if there are no more steps.
    function advanceDish(dishIndex) {
        const dish = activeDishes[dishIndex];

        if (dish.currentStep < dish.steps.length - 1) {
            // Move to the next step
            dish.currentStep++;
            // Re-render just this dish's card with the new step
            renderDishCard(dishIndex);
        } else {
            // No more steps ‚Äî this dish is fully done
            dish.done = true;
            renderDishCard(dishIndex);
        }
    }


    // playBeep() ‚Äî Generates a short beep sound using the Web Audio API.
    // No sound files needed ‚Äî we create the sound from scratch!
    function playBeep() {
        try {
            // AudioContext is the browser's built-in sound synthesizer
            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

            // An "oscillator" generates a tone (like a tuning fork)
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            // Set the pitch (frequency) ‚Äî 880 Hz is a high A note
            oscillator.frequency.value = 880;
            oscillator.type = "sine";

            // Set volume
            gainNode.gain.value = 0.3;

            // Play for 0.3 seconds
            oscillator.start();
            oscillator.stop(audioCtx.currentTime + 0.3);

            // Play a second beep after a short pause
            setTimeout(function() {
                const osc2 = audioCtx.createOscillator();
                const gain2 = audioCtx.createGain();
                osc2.connect(gain2);
                gain2.connect(audioCtx.destination);
                osc2.frequency.value = 880;
                osc2.type = "sine";
                gain2.gain.value = 0.3;
                osc2.start();
                osc2.stop(audioCtx.currentTime + 0.3);
            }, 400);
        } catch (e) {
            // If audio fails (e.g., browser blocks it), just skip it
            console.log("Could not play beep:", e);
        }
    }


    // formatTimeForDisplay(date) ‚Äî Formats a Date as "6:00 PM" for display.
    function formatTimeForDisplay(date) {
        let hours = date.getHours();
        const minutes = String(date.getMinutes()).padStart(2, "0");
        const ampm = hours >= 12 ? "PM" : "AM";
        hours = hours % 12;
        if (hours === 0) hours = 12;
        return hours + ":" + minutes + " " + ampm;
    }


    // sendNotification(dish, action) ‚Äî Sends a desktop notification popup.
    function sendNotification(dish, action) {
        if ("Notification" in window && Notification.permission === "granted") {
            new Notification("üç≥ " + dish, {
                body: action,
                icon: "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üç≥</text></svg>"
            });
        }
    }


    // stopCooking() ‚Äî Stops all timers and returns to the setup screen.
    function stopCooking() {
        clearInterval(timerInterval);
        activeDishes = [];

        document.getElementById("timer-section").style.display = "none";
        document.getElementById("setup-section").style.display = "block";
    }


    // ---- SAVED DISHES (Firestore) ----
    //
    // Previously, saved dishes were stored in localStorage (browser-only).
    // Now they're stored in Firestore (Google's cloud database), so they:
    //   - Sync across all devices (phone, laptop, tablet)
    //   - Are private to each user (secured by Firestore rules)
    //   - Persist even if browser data is cleared
    //
    // Firestore structure:
    //   users/{userId}/dishes/{dishId}
    //     ‚Üí { name: "Pasta", steps: [{ action: "Boil water", minutes: 5 }, ...] }
    //
    // We use onSnapshot() to listen for real-time changes. This means if you
    // save a dish on your phone, it appears on your laptop instantly.

    // setupDishesListener(user) ‚Äî Starts (or stops) listening to a user's
    // saved dishes in Firestore. Called when auth state changes.
    function setupDishesListener(user) {
        // Clean up any previous listener
        if (unsubscribeDishes) {
            unsubscribeDishes();
            unsubscribeDishes = null;
        }

        if (!user) {
            // No user logged in ‚Äî clear the cache and panel
            cachedSavedDishes = [];
            renderSavedDishes();
            return;
        }

        // onSnapshot sets up a REAL-TIME LISTENER.
        // Every time the dishes collection changes (add, edit, delete),
        // this callback runs automatically ‚Äî no need to manually refresh.
        unsubscribeDishes = db.collection("users").doc(user.uid)
            .collection("dishes").onSnapshot(function(snapshot) {
                cachedSavedDishes = [];
                snapshot.forEach(function(doc) {
                    cachedSavedDishes.push({
                        id: doc.id,          // Firestore auto-generated ID
                        name: doc.data().name,
                        steps: doc.data().steps
                    });
                });
                renderSavedDishes();
            }, function(error) {
                console.log("Error listening to dishes:", error);
            });
    }


    // saveDish(dishId) ‚Äî Reads a dish card's name and steps from the DOM,
    // then saves it to Firestore under the current user's account.
    function saveDish(dishId) {
        const user = auth.currentUser;
        if (!user) {
            alert("You must be signed in to save dishes.");
            return;
        }

        const card = document.getElementById("dish-" + dishId);
        if (!card) return;

        const name = card.querySelector(".dish-name").value.trim();
        if (!name) {
            alert("Give the dish a name before saving.");
            return;
        }

        // Read all step rows from this dish card
        const stepRows = card.querySelectorAll(".step-row");
        const steps = [];

        stepRows.forEach(function(row) {
            const action = row.querySelector(".step-action").value.trim() || "Do something";
            const minutes = parseFloat(row.querySelector(".step-minutes").value) || 0;
            steps.push({ action: action, minutes: minutes });
        });

        if (steps.length === 0) {
            alert("Add at least one step before saving.");
            return;
        }

        // Reference to this user's dishes collection in Firestore
        const dishesRef = db.collection("users").doc(user.uid).collection("dishes");

        // Check if a dish with this name already exists (using our local cache)
        const existing = cachedSavedDishes.find(function(d) { return d.name === name; });

        if (existing) {
            // A dish with this name already exists ‚Äî ask to overwrite
            if (!confirm('"' + name + '" is already saved. Overwrite it?')) {
                return;
            }
            // Update the existing Firestore document
            dishesRef.doc(existing.id).set({ name: name, steps: steps });
        } else {
            // Add a new document (Firestore auto-generates a unique ID)
            dishesRef.add({ name: name, steps: steps });
        }
        // No need to call renderSavedDishes ‚Äî the onSnapshot listener does it!
    }


    // deleteSavedDish(docId) ‚Äî Removes a saved dish from Firestore.
    // docId is the Firestore document ID (a string like "abc123xyz").
    function deleteSavedDish(docId) {
        const user = auth.currentUser;
        if (!user) return;

        db.collection("users").doc(user.uid).collection("dishes").doc(docId).delete();
        // onSnapshot listener automatically updates the UI
    }


    // loadDish(docId) ‚Äî Creates a new dish card pre-filled with a saved
    // dish's name and steps. Reads from the local cache.
    function loadDish(docId) {
        const recipe = cachedSavedDishes.find(function(d) { return d.id === docId; });
        if (!recipe) return;

        // Create a new empty dish card
        dishCounter++;
        const dishId = dishCounter;

        const dishDiv = document.createElement("div");
        dishDiv.className = "dish-card";
        dishDiv.id = "dish-" + dishId;

        dishDiv.innerHTML =
            '<div class="dish-header">' +
                '<input type="text" placeholder="Dish name (e.g. Chicken)" class="dish-name">' +
                '<div class="dish-header-buttons">' +
                    '<button onclick="saveDish(' + dishId + ')" class="btn btn-save">Save</button>' +
                    '<button onclick="removeDish(' + dishId + ')" class="btn btn-remove">Remove</button>' +
                '</div>' +
            '</div>' +
            '<div class="steps-container" id="steps-' + dishId + '"></div>' +
            '<button onclick="addStep(' + dishId + ')" class="btn btn-add-step">+ Add Step</button>';

        document.getElementById("dishes-container").appendChild(dishDiv);

        // Fill in the dish name
        dishDiv.querySelector(".dish-name").value = recipe.name;

        // Add a step row for each saved step and fill in the values
        const stepsContainer = document.getElementById("steps-" + dishId);

        recipe.steps.forEach(function(step) {
            const stepDiv = document.createElement("div");
            stepDiv.className = "step-row";

            stepDiv.innerHTML =
                '<input type="text" placeholder="Action (e.g. Flip chicken)" class="step-action">' +
                '<input type="number" placeholder="Min" min="0" step="0.1" class="step-minutes" title="How long this step takes (decimals OK, e.g. 2.5 = 2m 30s)">' +
                '<span class="step-label">min</span>' +
                '<button onclick="this.parentElement.remove()" class="btn btn-remove-step">‚úï</button>';

            stepsContainer.appendChild(stepDiv);

            // Set the values from the saved recipe
            stepDiv.querySelector(".step-action").value = step.action;
            stepDiv.querySelector(".step-minutes").value = step.minutes;
        });
    }


    // renderSavedDishes() ‚Äî Rebuilds the saved dishes panel from the
    // cachedSavedDishes array (kept in sync with Firestore by onSnapshot).
    function renderSavedDishes() {
        const container = document.getElementById("saved-dishes-container");

        if (cachedSavedDishes.length === 0) {
            container.innerHTML =
                '<p class="saved-empty">No saved dishes yet. Use the "Save" button on a dish to save it.</p>';
            return;
        }

        container.innerHTML = "";

        cachedSavedDishes.forEach(function(dish) {
            const div = document.createElement("div");
            div.className = "saved-dish-row";

            // Build a short summary of the steps, e.g. "3 steps, 16 min total"
            const totalMin = dish.steps.reduce(function(sum, s) { return sum + s.minutes; }, 0);
            const totalDisplay = (totalMin % 1 === 0) ? totalMin : totalMin.toFixed(1);
            const summary = dish.steps.length + " step" + (dish.steps.length === 1 ? "" : "s") +
                ", " + totalDisplay + " min total";

            // dish.id is a Firestore document ID (string), so we quote it
            // with escaped single quotes in the onclick handler
            div.innerHTML =
                '<div class="saved-dish-info">' +
                    '<span class="saved-dish-name">' + dish.name + '</span>' +
                    '<span class="saved-dish-summary">' + summary + '</span>' +
                '</div>' +
                '<div class="saved-dish-buttons">' +
                    '<button onclick="loadDish(\'' + dish.id + '\')" class="btn btn-load">Load</button>' +
                    '<button onclick="deleteSavedDish(\'' + dish.id + '\')" class="btn btn-delete">Delete</button>' +
                '</div>';

            container.appendChild(div);
        });
    }


    // ---- INITIALIZE ----
    // Add one dish automatically when the page loads so it's not empty.
    // (The setup section is hidden until login ‚Äî this just pre-creates the card.)
    addDish();

    // Saved dishes are now loaded automatically by the Firestore onSnapshot
    // listener, which is set up when the user logs in (see setupDishesListener).

    </script>
</body>
</html>
